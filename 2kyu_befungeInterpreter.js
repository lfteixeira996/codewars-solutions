// Esoteric languages are pretty hard to program, but it's fairly interesting to
// write interpreters for them!

// Your task is to write a method which will interpret Befunge-93 code!
// Befunge-93 is a language in which the code is presented not as a series of
// instructions, but as instructions scattered on a 2D plane; your pointer
// starts at the top-left corner and defaults to moving right through the code.
// Note that the instruction pointer wraps around the screen! There is a
// singular stack which we will assume is unbounded and only contain integers.
// While Befunge-93 code is supposed to be restricted to 80x25, you need not be
// concerned with code size. Befunge-93 supports the following instructions
// (from Wikipedia):

// 0-9 Push this number onto the stack.
// + Addition: Pop a and b, then push a+b.
// - Subtraction: Pop a and b, then push b-a.
// * Multiplication: Pop a and b, then push a*b. / Integer division: Pop a and
//   b, then push b/a, rounded down. If a is zero, push zero. % Modulo: Pop a
//   and b, then push the b%a. If a is zero, push zero. ! Logical NOT: Pop a
//   value. If the value is zero, push 1; otherwise, push zero. ` (backtick)
//   Greater than: Pop a and b, then push 1 if b>a, otherwise push zero.
// > Start moving right. < Start moving left. ^ Start moving up. v Start moving
// down. ? Start moving in a random cardinal direction. _ Pop a value; move
// right if value = 0, left otherwise. | Pop a value; move down if value = 0, up
// otherwise. " Start string mode: push each character's ASCII value all the way
// up to the next ". : Duplicate value on top of the stack. If there is nothing
// on top of the stack, push a 0. \ Swap two values on top of the stack. If
// there is only one value, pretend there is an extra 0 on bottom of the stack.
// $ Pop value from the stack and discard it. . Pop value and output as an
// integer. , Pop value and output the ASCII character represented by the
// integer code that is stored in the value.
// # Trampoline: Skip next cell.
// p A "put" call (a way to store a value for later use). Pop y, x and v, then
// change the character at the position (x,y) in the program to the character
// with ASCII value v. g A "get" call (a way to retrieve data in storage). Pop y
// and x, then push ASCII value of the character at that position in the
// program. @ End program. (i.e. a space) No-op. Does nothing. The above list is
// slightly modified: you'll notice if you look at the Wikipedia page that we do
// not use the user input instructions and dividing by zero simply yields zero.

// Here's an example:

// >987v>.v v456<  : 321 ^ _@ will create the output 123456789.

// So what you must do is create a function such that when you pass in the
// Befunge code, the function returns the output that would be generated by the
// code. So, for example:

// "123456789".equals(new BefungeInterpreter().interpret(">987v>.v\nv456<
// :\n>321 ^ _@") This test case will be added for you.

"use strict";

class Befunge {
  constructor(code) {
    this.pointer = { x: 0, y: 0 };
    this.stack = [];
    this.movement = { x: 1, y: 0 };
    this.running = false;
    this.code = code.split("\n").map(v => v.split(""));
    this.stringMode = false;
    this.jump = false;
    this.output = "";

    this.up = { x: 0, y: -1 };
    this.down = { x: 0, y: 1 };
    this.right = { x: 1, y: 0 };
    this.left = { x: -1, y: 0 };
  }

  command(cmd) {
    if (this.jump) {
      this.jump = false;
      return;
    }

    if (this.stringMode) {
      if (cmd === '"') {
        this.stringMode = false;
      } else {
        this.stack.push(cmd.charCodeAt(0));
      }
      return;
    }

    let a, b, x, y, v;

    switch (cmd) {
      case "+":
        a = this.stack.pop();
        b = this.stack.pop();
        this.stack.push(a + (b || 0));
        break;
      case "-":
        a = this.stack.pop();
        b = this.stack.pop();
        this.stack.push((b || 0) - a);
        break;
      case "*":
        this.stack.push(this.stack.pop() * this.stack.pop());
        break;
      case "/":
        a = this.stack.pop();
        b = this.stack.pop();
        this.stack.push(a === 0 ? 0 : Math.floor(b / a));
        break;
      case "%":
        a = this.stack.pop();
        b = this.stack.pop();
        this.stack.push(a === 0 ? 0 : b % a);
        break;
      case "!":
        this.stack.push(this.stack.pop() === 0 ? 1 : 0);
        break;
      case "`":
        a = this.stack.pop();
        b = this.stack.pop();
        this.stack.push(b > a ? 1 : 0);
        break;
      case "^":
        this.movement = this.up;
        break;
      case "v":
        this.movement = this.down;
        break;
      case ">":
        this.movement = this.right;
        break;
      case "<":
        this.movement = this.left;
        break;
      case "?":
        this.movement = [this.up, this.down, this.left, this.right][
          Math.floor(Math.random() * 4)
        ];
        break;
      case "_":
        this.movement = this.stack.pop() === 0 ? this.right : this.left;
        break;
      case "|":
        this.movement = this.stack.pop() === 0 ? this.down : this.up;
        break;
      case '"':
        this.stringMode = true;
        break;
      case ":":
        a = this.stack.pop();
        if (a === undefined) {
          this.stack.push(0);
        } else {
          this.stack.push(a);
          this.stack.push(a);
        }
        break;
      case "\\":
        a = this.stack.pop();
        b = this.stack.pop();

        this.stack.push(a);
        this.stack.push(b === undefined ? 0 : b);
        break;
      case "$":
        this.stack.pop();
        break;
      case ".":
        this.output += this.stack.pop();
        break;
      case ",":
        a = this.stack.pop();
        this.output += String.fromCharCode(a);
        break;
      case "#":
        this.jump = true;
        break;
      case "p":
        y = this.stack.pop();
        x = this.stack.pop();
        v = this.stack.pop();

        this.code[y][x] = v;
        break;
      case "g":
        y = this.stack.pop();
        x = this.stack.pop();

        this.stack.push(
          this.code[y][x].charCodeAt
            ? this.code[y][x].charCodeAt(0)
            : this.code[y][x]
        );
        break;
      case "@":
        this.running = false;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        this.stack.push(+cmd);
        break;
      case " ":
        break;
      default:
        throw `${cmd} not recognized.`;
    }
  }

  move() {
    if (this.pointer.y + this.movement.y > this.code.length - 1) {
      this.pointer.y = 0;
    } else if (this.pointer.y + this.movement.y < 0) {
      this.pointer.y = this.code.length - 1;
    } else if (
      this.pointer.x + this.movement.x >
      this.code[this.pointer.y].length - 1
    ) {
      this.pointer.x = 0;
    } else if (this.pointer.x + this.movement.x < 0) {
      this.pointer.x = this.code[this.pointer.y].length - 1;
    } else {
      this.pointer.y = this.pointer.y + this.movement.y;
      this.pointer.x = this.pointer.x + this.movement.x;
    }
  }

  run() {
    this.running = true;

    while (this.running) {
      this.command(this.code[this.pointer.y][this.pointer.x]);
      this.move();
    }

    return this.output;
  }
}

const interpret = code => {
  let interpreter = new Befunge(code);
  return interpreter.run();
};

let i;
